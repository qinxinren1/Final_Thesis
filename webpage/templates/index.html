<!DOCTYPE html>
<html>
<head>
    <title>Music Measure Analyzer</title>
    <link rel="stylesheet" href="https://unpkg.com/wavesurfer.js@6.6.3/dist/wavesurfer.min.css">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
    <!-- Add Tone.js and Soundfont libraries for MIDI playback -->
    <script src="https://unpkg.com/tone@14.7.77/build/Tone.js"></script>
    <script src="https://unpkg.com/soundfont-player@0.12.0/dist/soundfont-player.min.js"></script>
    <script src="https://unpkg.com/@tonejs/midi@2.0.28/build/Midi.js"></script>
</head>
<body>
    <div class="container">
        <h1>Music Measure Analyzer</h1>
        
        {% if error %}
            <div class="alert error">{{ error }}</div>
        {% endif %}
        
        <form method="post" enctype="multipart/form-data">
            <input type="file" name="file" accept=".mp3,.wav,.mid" required>
            <div class="options">
                <label>
                    <input type="checkbox" name="separate_tracks" value="true">
                    Separate tracks using Demucs (GPU processing)
                </label>
            </div>
            <button type="submit">Analyze</button>
        </form>

        {% if analysis %}
            <div class="results">
                <div class="summary">
                    <h2>Analysis Results</h2>
                    <p>Tempo: <strong>{{ analysis.tempo }} BPM</strong></p>
                    <p>Time Signature: <strong>{{ analysis.time_sig }}</strong></p>
                    <p>Duration: <strong>{{ analysis.duration }} seconds</strong></p>
                    
                    {% if analysis.is_midi %}
                        <p>MIDI Format: <strong>{{ analysis.format }}</strong></p>
                        <p>Number of Tracks: <strong>{{ analysis.tracks_count }}</strong></p>
                    {% endif %}
                    
                    {% if analysis.separation_job_id %}
                        <div id="separation-status" data-job-id="{{ analysis.separation_job_id }}">
                            <h3>Track Separation</h3>
                            <p>Status: <span id="job-status" class="{{ analysis.separation_status }}">{{ analysis.separation_status }}</span></p>
                            <div id="status-message"></div>
                            <div id="separated-tracks" style="display: none;">
                                <h4>Separated Tracks</h4>
                                <div id="track-players"></div>
                            </div>
                        </div>
                    {% endif %}
                </div>

                {% if not analysis.is_midi %}
                <div id="waveform"></div>
                
                <div class="controls">
                    <button onclick="playAll()">▶ Play All</button>
                    <button onclick="wavesurfer.pause()">⏸ Pause</button>
                    <button onclick="stopPlayback()">⏹ Stop</button>
                    <div id="time-display">0:00 / 0:00</div>
                </div>

                <div class="measures">
                    <h3>Measures</h3>
                    <div class="measure-grid">
                        {% for measure in analysis.measures %}
                            <div class="measure" 
                                 data-start="{{ measure.start }}"
                                 data-end="{{ measure.end }}"
                                 onclick="playMeasure(this)">
                                <div class="measure-number">Measure {{ measure.number }}</div>
                                <div class="measure-time">
                                    {{ "%.2f"|format(measure.start) }}s - 
                                    {{ "%.2f"|format(measure.end) }}s
                                </div>
                                <div class="beats-container">
                                    {% for beat in measure.beats %}
                                        {% if beat.is_strong %}
                                        <div class="beat-indicator strong clickable"
                                             data-time="{{ beat.time }}"
                                             data-strength="{{ beat.strength }}"
                                             onclick="handleBeatClick(event, this)"
                                             title="Beat strength: {{ "%.2f"|format(beat.strength) }}">
                                            <div class="beat-strength" style="height: {{ beat.strength * 100 }}%"></div>
                                        </div>
                                        {% endif %}
                                    {% endfor %}
                                </div>
                            </div>
                        {% endfor %}
                    </div>
                </div>
                {% endif %}
                
                {% if analysis.is_midi %}
                <div id="midi-player-container">
                    <h3>MIDI Tracks</h3>
                    <div id="midi-tracks">
                        {% for track in analysis.tracks %}
                        <div class="midi-track">
                            <!-- Row 1: Track info and controls -->
                            <div class="midi-track-header">
                                <div class="midi-track-info">
                                    <div class="track-title">
                                        <h4>{{ track.name }}</h4>
                                        <p>Notes: <strong>{{ track.notes_count }}</strong></p>
                                    </div>
                                    <div class="instrument-container">
                                        {% if track.instruments|length > 0 %}
                                            {% for instrument in track.instruments %}
                                            <span class="instrument-tag">{{ instrument.name }}</span>
                                            {% endfor %}
                                        {% endif %}
                                    </div>
                                </div>
                                <div class="midi-track-controls">
                                    <button onclick="playMidiTrack('{{ track.number }}')" class="play-button">▶ Play Track</button>
                                    <button onclick="stopMidiTrack('{{ track.number }}')" style="display:none;" id="stop-button-{{ track.number }}" class="stop-button">⏹ Stop</button>
                                    <span id="midi-status-{{ track.number }}" class="midi-status"></span>
                                    <span id="midi-time-display-{{ track.number }}" class="midi-time-display">0:00 / 0:00</span>
                                </div>
                            </div>
                            
                            <!-- Row 2: Piano roll visualization -->
                            <div class="midi-visualization-container">
                                <canvas id="midi-piano-roll-{{ track.number }}" height="20" width="100%" class="interactive-piano-roll" data-track-num="{{ track.number }}"></canvas>
                                <div class="midi-progress-container" data-track-num="{{ track.number }}">
                                    <div id="midi-progress-bar-{{ track.number }}" class="midi-progress-bar"></div>
                                </div>
                            </div>
                        </div>
                        {% endfor %}
                    </div>
                </div>
                {% endif %}
            </div>
        {% endif %}
    </div>

    <script src="https://unpkg.com/wavesurfer.js@6.6.3/dist/wavesurfer.min.js"></script>
    {% if analysis %}
        <script>
            {% if not analysis.is_midi %}
            const wavesurfer = WaveSurfer.create({
                container: '#waveform',
                waveColor: '#4a90e2',
                progressColor: '#2d5f8b',
                cursorColor: '#333',
                height: 150,
                normalize: true,
                responsive: true
            });

            let activeMeasure = null;
            let playbackTimer = null;
            let measures = [];
            let audioContext = null;
            let clickSound = null;

            // Initialize audio context and create click sound
            function initAudio() {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // Create a simple click sound
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(880, audioContext.currentTime); // A5 note
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                clickSound = { oscillator, gainNode };
            }

            // Handle beat click
            function handleBeatClick(event, beatElement) {
                event.stopPropagation(); // Prevent measure click event
                
                const beatTime = parseFloat(beatElement.dataset.time);
                
                // Play just this beat
                wavesurfer.play(beatTime);
                wavesurfer.setCurrentTime(beatTime);
                
                // Stop after a short duration (0.1 seconds)
                setTimeout(() => {
                    wavesurfer.stop();
                }, 100);
                
                // Visual feedback
                beatElement.classList.add('clicked');
                setTimeout(() => {
                    beatElement.classList.remove('clicked');
                }, 200);
            }

            // Handle measure click
            function playMeasure(measureElement) {
                const startTime = parseFloat(measureElement.dataset.start);
                const endTime = parseFloat(measureElement.dataset.end);
                
                // Play only the segment within this measure
                wavesurfer.play(startTime);
                wavesurfer.setCurrentTime(startTime);
                
                // Stop at the end of the measure
                setTimeout(() => {
                    wavesurfer.stop();
                }, (endTime - startTime) * 1000);
                
                // Visual feedback for the measure
                measureElement.classList.add('active');
                setTimeout(() => {
                    measureElement.classList.remove('active');
                }, (endTime - startTime) * 1000);
            }

            // Play the entire audio file
            function playAll() {
                wavesurfer.play();
            }

            wavesurfer.load('{{ analysis.audio_url }}');

            // Track current time and highlight beats
            wavesurfer.on('audioprocess', function() {
                const currentTime = wavesurfer.getCurrentTime();
                updateTimeDisplay(currentTime);
                
                // Find and highlight beats that match the current time
                const allBeats = document.querySelectorAll('.beat-indicator');
                allBeats.forEach(beat => {
                    const beatTime = parseFloat(beat.dataset.time);
                    // Use a small threshold (0.05 seconds) to account for timing differences
                    if (Math.abs(currentTime - beatTime) < 0.05) {
                        beat.classList.add('active');
                    } else {
                        beat.classList.remove('active');
                    }
                });
                
                // Find and highlight the current measure
                const allMeasures = document.querySelectorAll('.measure');
                allMeasures.forEach(measure => {
                    const measureStart = parseFloat(measure.dataset.start);
                    const measureEnd = parseFloat(measure.dataset.end);
                    
                    if (currentTime >= measureStart && currentTime < measureEnd) {
                        measure.classList.add('active');
                        activeMeasure = measure;
                    } else {
                        measure.classList.remove('active');
                    }
                });
            });

            // Handle manual stops
            wavesurfer.on('pause', () => {
                if (activeMeasure) {
                    activeMeasure.classList.remove('active');
                    activeMeasure = null;
                }
                // Remove highlighting from all beats
                document.querySelectorAll('.beat-indicator').forEach(beat => {
                    beat.classList.remove('active');
                });
            });

            wavesurfer.on('finish', () => {
                if (activeMeasure) {
                    activeMeasure.classList.remove('active');
                    activeMeasure = null;
                }
                // Remove highlighting from all beats
                document.querySelectorAll('.beat-indicator').forEach(beat => {
                    beat.classList.remove('active');
                });
            });

            // Format time for display (MM:SS)
            function formatTime(timeInSeconds) {
                const minutes = Math.floor(timeInSeconds / 60);
                const seconds = Math.floor(timeInSeconds % 60);
                return `${minutes}:${seconds.toString().padStart(2, '0')}`;
            }

            // Update time display
            function updateTimeDisplay(currentTime) {
                const timeDisplay = document.getElementById('time-display');
                const duration = wavesurfer.getDuration() || 0;
                timeDisplay.textContent = `${formatTime(currentTime)} / ${formatTime(duration)}`;
            }

            // Initialize time display when audio is loaded
            wavesurfer.on('ready', function() {
                updateTimeDisplay(0);
            });

            // Function to handle the Stop button click
            function stopPlayback() {
                // Stop any current playback
                wavesurfer.stop();
                if (playbackTimer) clearTimeout(playbackTimer);
                
                // Clear any active measure
                if (activeMeasure) {
                    activeMeasure.classList.remove('active');
                    activeMeasure = null;
                }
            }
            {% endif %}
            
            {% if analysis.is_midi %}
            // Handle MIDI track playback with Tone.js and Soundfont
            const midiPlayers = {};
            const audioContext = new AudioContext();

            // Initialize Tone.js
            try {
                Tone.start();
            } catch (e) {
                console.error("Error starting Tone.js:", e);
            }

            // Format time for display (MM:SS)
            function formatTime(timeInSeconds) {
                const minutes = Math.floor(timeInSeconds / 60);
                const seconds = Math.floor(timeInSeconds % 60);
                return `${minutes}:${seconds.toString().padStart(2, '0')}`;
            }

            // Draw piano roll visualization for MIDI track
            function drawPianoRoll(trackNum, notes) {
                const canvas = document.getElementById(`midi-piano-roll-${trackNum}`);
                if (!canvas) return;
                
                const ctx = canvas.getContext('2d');
                const width = canvas.width;
                const height = canvas.height;
                
                // Clear the canvas
                ctx.clearRect(0, 0, width, height);
                
                if (!notes || notes.length === 0) {
                    ctx.fillStyle = '#f0f0f0';
                    ctx.fillRect(0, 0, width, height);
                    ctx.fillStyle = '#999';
                    ctx.font = '14px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('No note data available', width/2, height/2);
                    return;
                }
                
                // Find duration of track and note range
                let maxTime = 0;
                let minNote = 127;
                let maxNote = 0;
                
                notes.forEach(note => {
                    const endTime = note.startTime + note.duration;
                    if (endTime > maxTime) maxTime = endTime;
                    if (note.note < minNote) minNote = note.note;
                    if (note.note > maxNote) maxNote = note.note;
                });
                
                // Add some padding to the note range
                minNote = Math.max(0, minNote - 5);
                maxNote = Math.min(127, maxNote + 5);
                const noteRange = maxNote - minNote + 1;
                
                // Draw background
                ctx.fillStyle = '#f8f9fa';
                ctx.fillRect(0, 0, width, height);
                
                // Draw horizontal lines for octaves
                ctx.strokeStyle = '#e0e0e0';
                ctx.lineWidth = 1;
                for (let octave = Math.floor(minNote / 12); octave <= Math.floor(maxNote / 12); octave++) {
                    const y = height - ((octave * 12 - minNote) / noteRange) * height;
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(width, y);
                    ctx.stroke();
                }
                
                // Draw notes
                notes.forEach(note => {
                    const x = (note.startTime / maxTime) * width;
                    const noteWidth = (note.duration / maxTime) * width;
                    const y = height - ((note.note - minNote) / noteRange) * height;
                    const noteHeight = height / noteRange;
                    
                    // Color based on velocity
                    const intensity = Math.min(1, note.velocity * 1.5);
                    ctx.fillStyle = `rgba(74, 144, 226, ${intensity})`;
                    
                    // Draw rounded rect for the note
                    const radius = Math.min(4, noteHeight / 2);
                    ctx.beginPath();
                    ctx.moveTo(x + radius, y);
                    ctx.lineTo(x + noteWidth - radius, y);
                    ctx.quadraticCurveTo(x + noteWidth, y, x + noteWidth, y + radius);
                    ctx.lineTo(x + noteWidth, y + noteHeight - radius);
                    ctx.quadraticCurveTo(x + noteWidth, y + noteHeight, x + noteWidth - radius, y + noteHeight);
                    ctx.lineTo(x + radius, y + noteHeight);
                    ctx.quadraticCurveTo(x, y + noteHeight, x, y + noteHeight - radius);
                    ctx.lineTo(x, y + radius);
                    ctx.quadraticCurveTo(x, y, x + radius, y);
                    ctx.closePath();
                    ctx.fill();
                });
                
                // Store track data for progress updates
                if (!midiPlayers[trackNum]) {
                    midiPlayers[trackNum] = {};
                }
                midiPlayers[trackNum].trackDuration = maxTime;
                midiPlayers[trackNum].noteData = {
                    notes,
                    maxTime,
                    minNote,
                    maxNote,
                    noteRange
                };
                
                // Add click event listener for interactive playback
                if (!canvas.hasClickListener) {
                    canvas.addEventListener('click', function(event) {
                        // Get the click position relative to the canvas
                        const rect = canvas.getBoundingClientRect();
                        const x = event.clientX - rect.left;
                        
                        // Calculate the time position based on x coordinate
                        const timePosition = (x / rect.width) * maxTime;
                        
                        // If player exists, play from that position
                        if (midiPlayers[trackNum] && midiPlayers[trackNum].isLoaded) {
                            playMidiTrackFromPosition(trackNum, timePosition);
                        } else {
                            // Load and then play
                            playMidiTrack(trackNum, timePosition);
                        }
                    });
                    canvas.hasClickListener = true;
                }
                
                // Also add click event listener to the progress container
                const progressContainer = document.querySelector(`.midi-progress-container[data-track-num="${trackNum}"]`);
                if (progressContainer && !progressContainer.hasClickListener) {
                    progressContainer.addEventListener('click', function(event) {
                        const rect = progressContainer.getBoundingClientRect();
                        const x = event.clientX - rect.left;
                        const timePosition = (x / rect.width) * maxTime;
                        
                        if (midiPlayers[trackNum] && midiPlayers[trackNum].isLoaded) {
                            playMidiTrackFromPosition(trackNum, timePosition);
                        } else {
                            playMidiTrack(trackNum, timePosition);
                        }
                    });
                    progressContainer.hasClickListener = true;
                }
            }

            // Update the progress bar and time display
            function updateMidiProgress(trackNum, currentTime, duration) {
                // Update progress bar
                const progressBar = document.getElementById(`midi-progress-bar-${trackNum}`);
                if (progressBar) {
                    const progress = (currentTime / duration) * 100;
                    progressBar.style.width = `${progress}%`;
                }
                
                // Update time display
                const timeDisplay = document.getElementById(`midi-time-display-${trackNum}`);
                if (timeDisplay) {
                    timeDisplay.textContent = `${formatTime(currentTime)} / ${formatTime(duration)}`;
                }
            }

            function playMidiTrack(trackNum, startPosition = 0) {
                const statusElement = document.getElementById(`midi-status-${trackNum}`);
                const stopButton = document.getElementById(`stop-button-${trackNum}`);
                statusElement.textContent = "Loading...";
                statusElement.className = "midi-status loading";
                
                if (midiPlayers[trackNum] && midiPlayers[trackNum].isLoaded) {
                    // If player exists, play from position
                    statusElement.textContent = "Playing";
                    statusElement.className = "midi-status playing";
                    stopButton.style.display = 'inline-block';
                    
                    if (startPosition > 0) {
                        midiPlayers[trackNum].startFromPosition(startPosition);
                    } else {
                        midiPlayers[trackNum].start();
                    }
                    return;
                }
                
                // Request the server to extract and serve this track
                fetch(`/midi_track/{{ analysis.midi_url.split('/')[-1] }}/${trackNum}`)
                    .then(response => response.json())
                    .then(data => {
                        if (data.error) {
                            statusElement.textContent = `Error: ${data.error}`;
                            statusElement.className = "midi-status error";
                            return;
                        }
                        
                        // Get track data
                        const notes = data.notes;
                        const instrumentName = data.instrument;
                        
                        // Draw the piano roll visualization
                        drawPianoRoll(trackNum, notes);
                        
                        // Load instrument with Soundfont player
                        Soundfont.instrument(audioContext, instrumentName)
                            .then(instrument => {
                                // Create player for this track
                                const player = {
                                    instrument,
                                    notes,
                                    isLoaded: true,
                                    isPlaying: false,
                                    noteTimers: [],
                                    progressInterval: null,
                                    trackDuration: midiPlayers[trackNum] ? midiPlayers[trackNum].trackDuration : 0,
                                    startTime: 0,
                                    
                                    start: function() {
                                        this.startFromPosition(0);
                                    },
                                    
                                    startFromPosition: function(startPosition) {
                                        this.stop(); // Stop any existing playback
                                        this.isPlaying = true;
                                        this.startTime = Date.now() - (startPosition * 1000); // Adjust start time to account for position
                                        
                                        // Reset the visualization and show the current position
                                        updateMidiProgress(trackNum, startPosition, this.trackDuration);
                                        
                                        // Start progress tracking
                                        this.progressInterval = setInterval(() => {
                                            if (this.isPlaying) {
                                                const currentTime = (Date.now() - this.startTime) / 1000;
                                                updateMidiProgress(trackNum, currentTime, this.trackDuration);
                                                
                                                // Stop progress updates if we've reached the end
                                                if (currentTime >= this.trackDuration) {
                                                    clearInterval(this.progressInterval);
                                                }
                                            }
                                        }, 50); // Update every 50ms for smooth animation
                                        
                                        // Filter notes that should be played from the start position
                                        const notesToPlay = this.notes.filter(note => 
                                            (note.startTime + note.duration) > startPosition
                                        );
                                        
                                        // Play each note at its start time, adjusted for the start position
                                        notesToPlay.forEach(note => {
                                            // Calculate adjusted start time
                                            const adjustedStartTime = Math.max(0, note.startTime - startPosition);
                                            
                                            // Map MIDI note number to note name
                                            const noteName = this.midiNoteToName(note.note);
                                            
                                            // Schedule note to play at the right time
                                            const noteTimer = setTimeout(() => {
                                                if (this.isPlaying) {
                                                    // If the note should have started before the start position,
                                                    // adjust the duration to play only the remaining portion
                                                    let noteDuration = note.duration;
                                                    if (note.startTime < startPosition) {
                                                        noteDuration = note.duration - (startPosition - note.startTime);
                                                    }
                                                    
                                                    this.instrument.play(noteName, audioContext.currentTime, {
                                                        duration: noteDuration,
                                                        gain: note.velocity
                                                    });
                                                }
                                            }, adjustedStartTime * 1000);
                                            
                                            this.noteTimers.push(noteTimer);
                                        });
                                        
                                        // Calculate end time for the track
                                        if (notesToPlay.length > 0) {
                                            const lastNote = notesToPlay.reduce((latest, note) => {
                                                const endTime = note.startTime + note.duration;
                                                return endTime > latest ? endTime : latest;
                                            }, 0);
                                            
                                            // Calculate the remaining duration
                                            const remainingDuration = lastNote - startPosition;
                                            
                                            // Set up end callback
                                            this.noteTimers.push(setTimeout(() => {
                                                if (this.isPlaying) {
                                                    this.isPlaying = false;
                                                    statusElement.textContent = "Stopped";
                                                    statusElement.className = "midi-status stopped";
                                                    stopButton.style.display = 'none';
                                                    clearInterval(this.progressInterval);
                                                    updateMidiProgress(trackNum, this.trackDuration, this.trackDuration);
                                                }
                                            }, remainingDuration * 1000 + 100)); // Small buffer
                                        }
                                    },
                                    
                                    stop: function() {
                                        this.isPlaying = false;
                                        
                                        // Clear all scheduled notes
                                        this.noteTimers.forEach(timer => clearTimeout(timer));
                                        this.noteTimers = [];
                                        
                                        // Stop progress tracking
                                        if (this.progressInterval) {
                                            clearInterval(this.progressInterval);
                                            this.progressInterval = null;
                                        }
                                        
                                        // Stop any currently playing notes
                                        this.instrument.stop();
                                    },
                                    
                                    // Helper to convert MIDI note numbers to note names
                                    midiNoteToName: function(midiNote) {
                                        const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
                                        const octave = Math.floor(midiNote / 12) - 1;
                                        const noteName = noteNames[midiNote % 12];
                                        return noteName + octave;
                                    }
                                };
                                
                                // Store the player
                                midiPlayers[trackNum] = player;
                                
                                // Start playback
                                statusElement.textContent = "Playing";
                                statusElement.className = "midi-status playing";
                                stopButton.style.display = 'inline-block';
                                
                                if (startPosition > 0) {
                                    player.startFromPosition(startPosition);
                                } else {
                                    player.start();
                                }
                            })
                            .catch(error => {
                                console.error("Error loading instrument:", error);
                                statusElement.textContent = `Error loading instrument: ${error.message}`;
                                statusElement.className = "midi-status error";
                            });
                    })
                    .catch(error => {
                        console.error("Error playing MIDI track:", error);
                        statusElement.textContent = `Error: ${error.message}`;
                        statusElement.className = "midi-status error";
                    });
            }

            function stopMidiTrack(trackNum) {
                if (midiPlayers[trackNum]) {
                    midiPlayers[trackNum].stop();
                    const statusElement = document.getElementById(`midi-status-${trackNum}`);
                    const stopButton = document.getElementById(`stop-button-${trackNum}`);
                    statusElement.textContent = "Stopped";
                    statusElement.className = "midi-status stopped";
                    stopButton.style.display = 'none';
                }
            }

            // Function to play from a specific position
            function playMidiTrackFromPosition(trackNum, startTime) {
                if (!midiPlayers[trackNum] || !midiPlayers[trackNum].isLoaded) {
                    console.error("Player not loaded for track", trackNum);
                    return;
                }
                
                const player = midiPlayers[trackNum];
                const statusElement = document.getElementById(`midi-status-${trackNum}`);
                const stopButton = document.getElementById(`stop-button-${trackNum}`);
                
                // Stop current playback
                player.stop();
                
                // Update UI
                statusElement.textContent = "Playing";
                statusElement.className = "midi-status playing";
                stopButton.style.display = 'inline-block';
                
                // Adjust playback position
                player.startFromPosition(startTime);
            }
            {% endif %}
            
            {% if analysis.separation_job_id %}
            // Check separation job status
            const separationStatus = document.getElementById('separation-status');
            const jobId = separationStatus.dataset.jobId;
            const statusSpan = document.getElementById('job-status');
            const statusMessage = document.getElementById('status-message');
            const separatedTracks = document.getElementById('separated-tracks');
            const trackPlayers = document.getElementById('track-players');
            
            function checkJobStatus() {
                fetch(`/check_separation/${jobId}`)
                    .then(response => response.json())
                    .then(data => {
                        // Update status class and text
                        statusSpan.textContent = data.status;
                        statusSpan.className = data.status;
                        
                        // Show appropriate message based on status
                        if (data.status === 'running') {
                            statusMessage.innerHTML = '<div class="status-info">Track separation is running. This may take a few minutes...</div>';
                        } else if (data.status === 'pending') {
                            statusMessage.innerHTML = '<div class="status-info">Job is pending in the DelftBlue queue. Waiting for resources...</div>';
                        } else if (data.status === 'queued') {
                            statusMessage.innerHTML = `<div class="status-info">Job is in the DelftBlue queue. ${data.details || ''}</div>`;
                        } else if (data.status === 'submitted') {
                            statusMessage.innerHTML = '<div class="status-info">Job submitted to DelftBlue cluster. Waiting for execution...</div>';
                        } else if (data.status === 'error') {
                            let errorMsg = '<div class="status-error">An error occurred during track separation. Please try again.';
                            if (data.error_details) {
                                errorMsg += '<button onclick="toggleErrorDetails()" class="error-toggle">Show Details</button>';
                                errorMsg += `<div id="error-details" style="display: none; margin-top: 10px; font-family: monospace; font-size: 0.8em; white-space: pre-wrap; overflow-x: auto; background: #f8f8f8; padding: 10px; border: 1px solid #ddd; border-radius: 4px;">${data.error_details}</div>`;
                            }
                            errorMsg += '</div>';
                            statusMessage.innerHTML = errorMsg;
                        } else if (data.status === 'unknown') {
                            statusMessage.innerHTML = `<div class="status-warning">Job status unknown. It may have failed or been cancelled. ${data.details || ''}</div>`;
                        } else if (data.status === 'not_found') {
                            statusMessage.innerHTML = '<div class="status-error">Job not found. Please try again.</div>';
                        }
                        
                        if (data.status === 'completed' && data.tracks) {
                            separatedTracks.style.display = 'block';
                            statusMessage.innerHTML = '<div class="status-success">Track separation completed successfully!</div>';
                            
                            // Create players for each track
                            Object.entries(data.tracks).forEach(([trackName, trackUrl]) => {
                                // Check if player already exists
                                if (!document.getElementById(`player-${trackName}`)) {
                                    const trackDiv = document.createElement('div');
                                    trackDiv.className = 'track-player';
                                    trackDiv.id = `player-${trackName}`;
                                    trackDiv.innerHTML = `
                                        <h5>${trackName}</h5>
                                        <div id="waveform-${trackName}" class="track-waveform"></div>
                                        <div class="track-controls">
                                            <button onclick="playTrack('${trackName}')">▶ Play</button>
                                            <button onclick="pauseTrack('${trackName}')">⏸ Pause</button>
                                            <button onclick="stopTrack('${trackName}')">⏹ Stop</button>
                                            <button onclick="analyzeTrack('${trackName}')" class="analyze-btn">Analyze Track</button>
                                        </div>
                                    `;
                                    trackPlayers.appendChild(trackDiv);
                                    
                                    // Create wavesurfer instance for this track
                                    window[`wavesurfer_${trackName}`] = WaveSurfer.create({
                                        container: `#waveform-${trackName}`,
                                        waveColor: '#4a90e2',
                                        progressColor: '#2d5f8b',
                                        cursorColor: '#333',
                                        height: 80,
                                        normalize: true,
                                        responsive: true
                                    });
                                    
                                    window[`wavesurfer_${trackName}`].load(trackUrl);
                                }
                            });
                            
                            // Stop checking status
                            clearInterval(statusInterval);
                        } else if (data.status === 'error' || data.status === 'unknown') {
                            // Stop checking on error
                            clearInterval(statusInterval);
                        } else {
                            // Continue checking
                            console.log("Job status:", data.status);
                        }
                    })
                    .catch(error => {
                        console.error("Error checking job status:", error);
                        statusSpan.textContent = "Error checking status";
                        statusMessage.innerHTML = '<div class="status-error">Failed to check job status. Please refresh the page.</div>';
                    });
            }
            
            // Check status immediately and then every 5 seconds
            checkJobStatus();
            const statusInterval = setInterval(checkJobStatus, 5000);
            
            // Functions to control track playback
            function playTrack(trackName) {
                window[`wavesurfer_${trackName}`].play();
            }
            
            function pauseTrack(trackName) {
                window[`wavesurfer_${trackName}`].pause();
            }
            
            function stopTrack(trackName) {
                window[`wavesurfer_${trackName}`].stop();
            }
            
            // Function to toggle error details visibility
            function toggleErrorDetails() {
                const details = document.getElementById('error-details');
                const button = document.querySelector('.error-toggle');
                if (details.style.display === 'none') {
                    details.style.display = 'block';
                    button.textContent = 'Hide Details';
                } else {
                    details.style.display = 'none';
                    button.textContent = 'Show Details';
                }
            }
            
            // Function to analyze a specific track
            function analyzeTrack(trackName) {
                // Show loading message
                const statusMsg = document.createElement('div');
                statusMsg.className = 'status-info';
                statusMsg.textContent = `Analyzing ${trackName} track...`;
                statusMsg.id = 'analyze-status';
                
                // Replace any existing status message
                const existingStatus = document.getElementById('analyze-status');
                if (existingStatus) {
                    existingStatus.replaceWith(statusMsg);
                } else {
                    document.getElementById('status-message').appendChild(statusMsg);
                }
                
                // Make API call to analyze the track
                fetch(`/analyze_track/${jobId}/${trackName}`)
                    .then(response => response.json())
                    .then(data => {
                        if (data.error) {
                            statusMsg.className = 'status-error';
                            statusMsg.textContent = `Error analyzing track: ${data.error}`;
                            return;
                        }
                        
                        // Update the status message
                        statusMsg.className = 'status-success';
                        statusMsg.textContent = `Analysis of ${trackName} complete!`;
                        
                        // Create a new section for the track analysis
                        const analysisSection = document.createElement('div');
                        analysisSection.className = 'track-analysis';
                        analysisSection.innerHTML = `
                            <h3>Analysis of ${trackName}</h3>
                            <p>Tempo: <strong>${data.tempo} BPM</strong></p>
                            <p>Time Signature: <strong>${data.time_sig}</strong></p>
                            <p>Duration: <strong>${data.duration} seconds</strong></p>
                            <div id="track-measures-${trackName}" class="track-measures">
                                <h4>Measures</h4>
                                <div class="measure-grid">
                                    ${data.measures.map(measure => `
                                        <div class="measure" 
                                             data-start="${measure.start}"
                                             data-end="${measure.end}"
                                             onclick="playTrackMeasure('${trackName}', this)">
                                            <div class="measure-number">Measure ${measure.number}</div>
                                            <div class="measure-time">
                                                ${measure.start.toFixed(2)}s - 
                                                ${measure.end.toFixed(2)}s
                                            </div>
                                            <div class="beats-container">
                                                ${measure.beats.filter(beat => beat.is_strong).map(beat => `
                                                    <div class="beat-indicator strong clickable"
                                                         data-time="${beat.time}"
                                                         data-strength="${beat.strength}"
                                                         onclick="handleTrackBeatClick(event, '${trackName}', this)"
                                                         title="Beat strength: ${beat.strength.toFixed(2)}">
                                                        <div class="beat-strength" style="height: ${beat.strength * 100}%"></div>
                                                    </div>
                                                `).join('')}
                                            </div>
                                        </div>
                                    `).join('')}
                                </div>
                            </div>
                        `;
                        
                        // Add the analysis section to the page
                        const trackPlayer = document.getElementById(`player-${trackName}`);
                        
                        // Remove any existing analysis
                        const existingAnalysis = document.getElementById(`analysis-${trackName}`);
                        if (existingAnalysis) {
                            existingAnalysis.remove();
                        }
                        
                        // Add the new analysis
                        analysisSection.id = `analysis-${trackName}`;
                        trackPlayer.after(analysisSection);
                    })
                    .catch(error => {
                        console.error("Error analyzing track:", error);
                        statusMsg.className = 'status-error';
                        statusMsg.textContent = `Error analyzing track: ${error.message}`;
                    });
            }
            
            // Function to play a specific measure of a track
            function playTrackMeasure(trackName, measureElement) {
                const startTime = parseFloat(measureElement.dataset.start);
                const endTime = parseFloat(measureElement.dataset.end);
                
                // Play only the segment within this measure
                window[`wavesurfer_${trackName}`].play(startTime);
                window[`wavesurfer_${trackName}`].setCurrentTime(startTime);
                
                // Stop at the end of the measure
                setTimeout(() => {
                    window[`wavesurfer_${trackName}`].stop();
                }, (endTime - startTime) * 1000);
                
                // Visual feedback for the measure
                measureElement.classList.add('active');
                setTimeout(() => {
                    measureElement.classList.remove('active');
                }, (endTime - startTime) * 1000);
            }
            
            // Function to handle beat click for a track
            function handleTrackBeatClick(event, trackName, beatElement) {
                event.stopPropagation(); // Prevent measure click event
                
                const beatTime = parseFloat(beatElement.dataset.time);
                
                // Play just this beat
                window[`wavesurfer_${trackName}`].play(beatTime);
                window[`wavesurfer_${trackName}`].setCurrentTime(beatTime);
                
                // Stop after a short duration (0.1 seconds)
                setTimeout(() => {
                    window[`wavesurfer_${trackName}`].stop();
                }, 100);
                
                // Visual feedback
                beatElement.classList.add('clicked');
                setTimeout(() => {
                    beatElement.classList.remove('clicked');
                }, 200);
            }
            {% endif %}
        </script>
    {% endif %}
</body>
</html>

